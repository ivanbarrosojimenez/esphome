esphome:
  name: pantalla-rack-1
  friendly_name: pantalla-rack-1
  on_boot:
    priority: -10
    then:
      - script.execute: refresh_loop

esp32: 
  board: seeed_xiao_esp32c3
  variant: esp32c3
  framework:
    type: arduino

web_server:
  port: 80

logger:
  level: ERROR

api:
  encryption:
    key: !secret api_key
  reboot_timeout: 0s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  ap:
    ssid: "pantalla-c3-fallback"
    password: !secret ap_password

captive_portal:

ota:
  platform: esphome

spi:
  clk_pin: GPIO7
  mosi_pin: GPIO6

globals:
  - id: pantalla_activa
    type: bool
    restore_value: yes
    initial_value: 'false'

color:
  - id: color_negro
    hex: "FFFFFF"   # Invertido para e-paper
  - id: color_blanco
    hex: "000000"   # Invertido para e-paper
  - id: color_rojo
    hex: "FF0000"
font:
  - file: "../fonts/SpringEgg.ttf"
    id: fuente_28
    size: 28
  - file: "../fonts/SpringEgg.ttf"
    id: fuente_8
    size: 8
  - file: "../fonts/SpringEgg.ttf"
    id: fuente_14
    size: 14
sensor:
  # CPU frigate proxmox
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_proxmox_200_cpu_used
    id: cpu_usage
  # RAM frigate proxmox
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_proxmox_200_memory_total
    id: ram_total
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_proxmox_200_memory_used
    id: ram_used
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_proxmox_200_memory_used_percentage
    id: ram_percent
  # CPU & RAM PROMXMOX2
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_400_cpu_used
    id: cpu_usage2
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_400_memory_total
    id: ram_total2
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_400_memory_used
    id: ram_used2
  - platform: homeassistant
    entity_id: sensor.lxc_frigate_400_memory_used_percentage
    id: ram_percent2

  #Temperaturas
  - platform: homeassistant
    entity_id: sensor.calidad_aire_madrid_temperature
    id: temperatura_interior
  - platform: homeassistant
    entity_id: sensor.calidad_aire_madrid_humidity
    id: humedad_interior


  - platform: homeassistant
    entity_id: sensor.temperatura_calle_solar_madrid_temperature
    id: temperatura_exterior
  - platform: homeassistant
    entity_id: sensor.temperatura_calle_solar_madrid_humidity
    id: humedad_exterior
  

text_sensor:
  # Frigate status
  - platform: homeassistant
    entity_id: sensor.frigate_status_2
    id: frigateA_status
  
  - platform: homeassistant
    entity_id: sensor.frigate_status
    id: frigateM_status
    #Vm status
  - platform: homeassistant
    entity_id: sensor.qemu_debian960_151_status
    id: debian1_status
  - platform: homeassistant
    entity_id: sensor.qemu_debianp2_123_status
    id: debian2_status


display:
  - platform: waveshare_epaper
    model: wa2.90in3c
    cs_pin: GPIO5
    dc_pin: GPIO2
    reset_pin: GPIO1
    busy_pin: GPIO0
    rotation: 90
    reset_duration: 2ms
    update_interval: never
    auto_clear_enabled: true
    id: main_display
    lambda: |-
      /*No pintar si no esta habilitado o gente en casa*/
      if (!id(refresh_enabled).state || !id(gente_en_casa).state) {
        return;
      }
      
      // 2. Hora válida
      auto now = id(esptime).now();
      if (!now.is_valid()) {
        return;
      }

      // 3. Ventana horaria
      int current_hour = now.hour;
      int start_h = (int) id(refresh_start_hour).state;
      int end_h   = (int) id(refresh_end_hour).state;

      bool horario_ok;

      if (start_h < end_h) {
        horario_ok = (current_hour >= start_h && current_hour < end_h);
      } else {
        horario_ok = (current_hour >= start_h || current_hour < end_h);
      }

      if (!horario_ok) {
        return;
      }

      // Limpiar pantalla
      it.fill(id(color_blanco));

      // Dimensiones de pantalla
      int screen_w = 296;
      int screen_h = 128;

      // Altura del bloque inferior (estados)
      int bottom_h = 15;

      // Separación real entre bloques
      int gap_h = 2;
      int divider_h = 1;

      // Altura correcta del bloque superior
      int top_h = screen_h - bottom_h - (gap_h * 2) - divider_h;

      // Ancho de cada columna del bloque superior
      int col_w = screen_w / 3;

      // Posición Y de la línea separadora
      int divider_y = top_h + gap_h;

      // Línea separadora
      it.line(0, divider_y, screen_w, divider_y, id(color_negro));

      // Líneas verticales del bloque superior
      it.line(col_w, 0, col_w, top_h, id(color_negro));
      it.line(col_w * 2, 0, col_w * 2, top_h, id(color_negro));

      // Títulos Frigate
      it.print(col_w / 2, 0, id(fuente_8), id(color_negro), TextAlign::TOP_CENTER, "Frigate A");
      it.print(col_w + col_w / 2, 0, id(fuente_8), id(color_negro), TextAlign::TOP_CENTER, "Frigate M");

      // Función para barras verticales
      auto draw_bar = [&](int x, int y_base, int segments, int filled, Color color) {
        int seg_h = 10;
        int seg_w = 14;
        for (int i = 0; i < segments; i++) {
          int y = y_base - i * (seg_h + 2);
          if (i < filled) {
            it.filled_rectangle(x, y, seg_w, seg_h, color);
          }
          it.rectangle(x, y, seg_w, seg_h, id(color_negro));
        }
      };

      // Base inferior de las barras (con margen real)
      int bar_base = top_h - 30;

      // ---- Frigate A ----
      int cpu_fa = isnan(id(cpu_usage).state) ? 0 : (int)(id(cpu_usage).state / 20);
      int ram_fa = isnan(id(ram_percent).state) ? 0 : (int)(id(ram_percent).state / 20);

      cpu_fa = std::min(cpu_fa, 5);
      ram_fa = std::min(ram_fa, 5);

      Color ram_fa_color = (id(ram_percent).state > 80) ? id(color_rojo) : id(color_negro);

      draw_bar(col_w / 2 - 20, bar_base, 5, cpu_fa, id(color_negro));
      draw_bar(col_w / 2 + 10, bar_base, 5, ram_fa, ram_fa_color);

      it.print(col_w / 2 - 13, bar_base + 9, id(fuente_8), id(color_negro), TextAlign::TOP_CENTER, "CPU");
      it.print(col_w / 2 + 17, bar_base + 9, id(fuente_8), id(color_negro), TextAlign::TOP_CENTER, "RAM");

      // ---- Frigate M ----
      int cpu_fm = isnan(id(cpu_usage2).state) ? 0 : (int)(id(cpu_usage2).state / 20);
      int ram_fm = isnan(id(ram_percent2).state) ? 0 : (int)(id(ram_percent2).state / 20);

      cpu_fm = std::min(cpu_fm, 5);
      ram_fm = std::min(ram_fm, 5);

      Color ram_fm_color = (id(ram_percent2).state > 80) ? id(color_rojo) : id(color_negro);

      draw_bar(col_w + col_w / 2 - 20, bar_base, 5, cpu_fm, id(color_negro));
      draw_bar(col_w + col_w / 2 + 10, bar_base, 5, ram_fm, ram_fm_color);


      it.print(col_w + col_w / 2 - 13, bar_base + 9, id(fuente_8), id(color_negro), TextAlign::TOP_CENTER, "CPU");
      it.print(col_w + col_w / 2 + 17, bar_base + 9, id(fuente_8), id(color_negro), TextAlign::TOP_CENTER, "RAM");

      // ---- Bloque derecho: hora + clima ----
      int info_x = col_w * 2 + 8;
      
      //Hora
      if (now.is_valid()) {
        char time_str[6];
        snprintf(time_str, sizeof(time_str), "%02d:%02d", now.hour, now.minute);
        it.print(info_x, -15, id(fuente_28), id(color_negro), time_str);
      }
      //Temperatura y humedad
      char buf[24];
      snprintf(buf, sizeof(buf), "        %.1fC", id(temperatura_interior).state);
      it.print(info_x, 36, id(fuente_14), id(color_negro), buf);

      snprintf(buf, sizeof(buf), "%.0f%%", id(humedad_interior).state);
      it.print(info_x, 44, id(fuente_14), id(color_negro), buf);

      snprintf(buf, sizeof(buf), "        %.1fC", id(temperatura_exterior).state);
      it.print(info_x, 72, id(fuente_14), id(color_negro), buf);

      snprintf(buf, sizeof(buf), "%.0f%%", id(humedad_exterior).state);
      it.print(info_x, 82, id(fuente_14), id(color_negro), buf);

      // ---- Bloque inferior: estados ----
      int status_y = divider_y + divider_h + gap_h;

      int step = screen_w / 5;
      const char* labels[5] = {"P1", "P2", "P3", "D1", "D2"};
      
      enum Estado {
        ESTADO_OK,
        ESTADO_KO,
        ESTADO_DESCONOCIDO
      };

      auto estado_from_string = [&](const std::string &state) {
        if (state.empty()) {
          return ESTADO_DESCONOCIDO;
        }

        std::string s = state;
        std::transform(s.begin(), s.end(), s.begin(), ::tolower);

        if (s.find("running") != std::string::npos ||
            s.find("online")  != std::string::npos ||
            s == "on") {
          return ESTADO_OK;
        }

        return ESTADO_KO;
      };


      Estado states_enum[5] = {
        id(proxmox_status).state ? ESTADO_OK : ESTADO_KO,
        id(proxmox2_status).state ? ESTADO_OK : ESTADO_KO,
        id(proxmox4_status).state ? ESTADO_OK : ESTADO_KO,
        estado_from_string(id(debian1_status).state),
        estado_from_string(id(debian2_status).state)
      };


      ESP_LOGD(
        "STATUS",
        "P1=%d | P2=%d | P3=%d | D1='%s' | D2='%s'",
        id(proxmox_status).state,
        id(proxmox2_status).state,
        id(proxmox4_status).state,
        id(debian1_status).state.c_str(),
        id(debian2_status).state.c_str()
      );
      ESP_LOGD(
        "STATUS",
        "RAW proxmox2: state=%d",
        id(proxmox2_status).state
      );


      for (int i = 0; i < 5; i++) {
        int cx = step * i + step / 2;

        it.print(cx - 10, status_y, id(fuente_8), id(color_negro), TextAlign::RIGHT, labels[i]);
        int cy = status_y + 8;
        int r  = 6;

        if (states_enum[i] == ESTADO_OK) {
          it.filled_circle(cx + 6, cy, r, id(color_negro));
        }
        else if (states_enum[i] == ESTADO_KO) {
          it.filled_circle(cx + 6, cy, r, id(color_rojo));
        }
        else {
          it.circle(cx + 6, cy, r, id(color_negro));
        }
      }

#interval:
#  - interval: 900s
#    then:
#      - if:
#          condition:
#            and:
#              - switch.is_on: refresh_enabled
#              - binary_sensor.is_on: gente_en_casa
#          then:
#            - component.update: main_display


time:
  - platform: sntp
    id: esptime
    timezone: "Europe/Madrid"

button:
  - platform: restart
    name: "Reiniciar ESP Pantalla"

  - platform: template
    name: "Forzar Deep Sleep Pantalla"
    on_press:
      then:
        - output.turn_off: power_sensors
        - delay: 2s
        - deep_sleep.enter:
            id: deep_sleep_1
            sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'

switch:
  - platform: template
    name: "Actualizar pantalla manual"
    id: update_display
    turn_on_action:
      - component.update: main_display
      - switch.turn_off: update_display

  - platform: template
    name: "Pantalla refresco habilitado"
    id: refresh_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

#Sensor HA
binary_sensor:
  - platform: homeassistant
    entity_id: input_boolean.gente_en_casa_madrid
    id: gente_en_casa

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox_status
    id: proxmox_status

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox2_status
    publish_initial_state: true
    id: proxmox2_status

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox4_status
    id: proxmox4_status

number:
  - platform: template
    name: "Duración activa Pantalla"
    id: run_time
    min_value: 1
    max_value: 360000
    initial_value: 12000
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true

  - platform: template
    name: "Tiempo en Deep Sleep Pantalla"
    id: sleep_time
    min_value: 10
    max_value: 3600
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true
    initial_value: 60

  - platform: template
    name: "Intervalo de refresco pantalla"
    id: refresh_control
    min_value: 1
    max_value: 120
    initial_value: 10
    step: 1
    unit_of_measurement: min
    restore_value: true
    optimistic: true


  - platform: template
    name: "Pantalla hora inicio"
    id: refresh_start_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 8
    optimistic: true
    restore_value: true

  - platform: template
    name: "Pantalla hora fin"
    id: refresh_end_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 22
    optimistic: true
    restore_value: true

output:
  - platform: gpio
    id: power_sensors
    pin: GPIO11

deep_sleep:
  id: deep_sleep_1

script:
  - id: go_to_sleep_delayed
    then:
      - delay: !lambda 'return (uint32_t)(id(run_time).state - 2) * 1000;'
      - output.turn_off: power_sensors
      - delay: 2s
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'
  - id: refresh_loop
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - if:
                condition:
                  and:
                    - switch.is_on: refresh_enabled
                    - binary_sensor.is_on: gente_en_casa
                then:
                  - component.update: main_display
            - delay: !lambda |-
                return (uint32_t)(id(refresh_control).state * 60 * 1000);