esphome:
  name: pantalla-calendario-4-2-1
  friendly_name: pantalla-calendario-4-2-1
  includes: ["src/pantalla_helpers.h"]
  on_boot:
    priority: -10
    then:
      - output.turn_off: led_builtin
      - script.execute: ensure_painted_on_boot
      - script.execute: refresh_loop
# external_components removed to prefer local custom_components/waveshare_epaper


esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino
web_server:
  port: 80

logger:
 # level: ERROR

api:
  encryption:
    key: !secret api_key
  reboot_timeout: 0s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  ap:
    ssid: "pantalla-c3-fallback"
    password: !secret ap_password

captive_portal:

ota:
  platform: esphome

globals:
  - id: pantalla_activa
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: force_refresh
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: last_refresh
    type: std::string
    restore_value: yes
    initial_value: ''
#Calendario
  - id: calendario_json
    type: std::string
    restore_value: yes
    initial_value: ''

  - id: last_calendar_hash
    type: std::string
    restore_value: yes
    initial_value: ''

  - id: last_processed_hash
    type: std::string
    restore_value: yes
    initial_value: ''

  - id: cal_changed
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: calendario_cache_ts
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_drawn_ok
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: using_cache
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: connection_error
    type: std::string
    restore_value: no
    initial_value: ''

  - id: eventos_texto
    type: std::vector<std::string>
    restore_value: no
  - id: cal_day
    type: std::vector<std::string>
  - id: cal_title
    type: std::vector<std::string>
  - id: cal_time
    type: std::vector<std::string>
  - id: cal_location
    type: std::vector<std::string>
  - id: cal_when
    type: std::vector<std::string>


color:
  - id: color_negro
    hex: "FFFFFF"   # Invertido para e-paper
  - id: color_blanco
    hex: "000000"   # Invertido para e-paper
  - id: color_dark_gray
    red_int: 169
    green_int: 169
    blue_int: 169
  - id: color_light_gray
    red_int: 84
    green_int: 84
    blue_int: 84


font:
  # Fuentes para título (tamaños variables)
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_16
    size: 16
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_18
    size: 18
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_28
    size: 20
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_22
    size: 22
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_24
    size: 24
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ

  # Fuentes para fecha (tamaños variables)
  - file: "../fonts/Palatino.ttf"
    id: fuente_fecha_12
    size: 12
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_14
    size: 16
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_fecha_18
    size: 18
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_fecha_20
    size: 20
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ

  - file: "../fonts/Roboto.ttf"
    id: fuente_8_2
    size: 12
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ

  - file: "../fonts/AtkinsonHyperlegibleNext-Bold.otf"
    id: fuente_8
    size: 12
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ


sensor:
  #Temperaturas
  - platform: homeassistant
    entity_id: sensor.calidad_aire_madrid_temperature
    id: temperatura_interior
  - platform: homeassistant
    entity_id: sensor.calidad_aire_madrid_humidity
    id: humedad_interior


  - platform: homeassistant
    entity_id: sensor.temperatura_calle_solar_madrid_temperature
    id: temperatura_exterior
  - platform: homeassistant
    entity_id: sensor.temperatura_calle_solar_madrid_humidity
    id: humedad_exterior
  

text_sensor:
#Sensor calendario
  - platform: homeassistant
    entity_id: sensor.calendario_barroso_eventos
    attribute: events_json
    id: calendario_eventos_raw

  - platform: template
    name: "Pantalla calendario last_refresh"
    id: pantalla_last_refresh
    lambda: |-
      return id(last_refresh);
# SPI (la e-paper no usa MISO)
spi:
  id: bus_epaper
  clk_pin: GPIO36      # SCL
  mosi_pin: GPIO35     # SDA (MOSI)

display:
  - platform: waveshare_epaper
    spi_id: bus_epaper
    display_mode: partial
    #display_mode: [ partial | full | fast | grayscale4 ]
    model: 4.20in-v2     # <- modelo del PR 6209
    cs_pin: GPIO10
    dc_pin: GPIO9
    reset_pin: GPIO8
    busy_pin: GPIO21
    rotation: 0
    # Automatic periodic updates disabled — controlled by `script.refresh_loop` using `refresh_control` (minutes)
    update_interval: never
    full_update_every: 300
    reset_duration: 200ms  # Aumentado para mejorar timing del reset (habitualmente 200–500ms en algunas unidades)
    auto_clear_enabled: false
    # Drawing logic extracted to src/pantalla_helpers.h — use draw_calendar(it)
    id: main_display
    lambda: |-
      draw_calendar(it);


#interval:
#  - interval: 900s
#    then:
#      - if:
#          condition:
#            and:
#              - switch.is_on: refresh_enabled
#              - binary_sensor.is_on: gente_en_casa
#          then:
#            - component.update: main_display


time:
  - platform: sntp
    id: esptime
    timezone: "Europe/Madrid"

button:
  - platform: restart
    name: "Reiniciar ESP Pantalla"

  - platform: template
    name: "Forzar Deep Sleep Pantalla"
    on_press:
      then:
        - output.turn_off: power_sensors
        - delay: 2s
        - deep_sleep.enter:
            id: deep_sleep_1
            sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'

switch:
  - platform: template
    name: "Actualizar pantalla manual"
    id: update_display
    turn_on_action:
      - globals.set:
          id: force_refresh
          value: 'true'
      - script.execute: procesar_calendario
      - delay: 2000ms
      
      # SIEMPRE actualizar pantalla cuando se pulsa el botón manual
      - component.update: main_display
      - delay: 500ms
      - globals.set:
          id: cal_changed
          value: 'false'
      - globals.set:
          id: last_drawn_ok
          value: 'true'
      - globals.set:
          id: force_refresh
          value: 'false'
      
      - if:
          condition:
            and:
              - switch.is_off: refresh_enabled
              - switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "Manual update complete and refresh disabled -> scheduling go_to_sleep_delayed");'
            - script.execute: go_to_sleep_delayed
      - switch.turn_off: update_display

  - platform: template
    name: "Pantalla refresco habilitado"
    id: refresh_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_off_action:
      - if:
          condition:
            switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "refresh disabled -> scheduling go_to_sleep_delayed");'
            - script.execute: go_to_sleep_delayed

  - platform: template
    name: "Pantalla auto-sleep habilitado"
    id: autosleep_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

select:
  - platform: template
    name: "UI tamaño fuente título"
    id: ui_font_title_size
    options:
      - "16"
      - "18"
      - "20"
      - "22"
      - "24"
    initial_option: "20"
    optimistic: true
    restore_value: true

  - platform: template
    name: "UI tamaño fuente fecha"
    id: ui_font_date_size
    options:
      - "12"
      - "14"
      - "16"
      - "18"
      - "20"
    initial_option: "16"
    optimistic: true
    restore_value: true

#Sensor HA
binary_sensor:
  - platform: homeassistant
    entity_id: input_boolean.gente_en_casa_madrid
    id: gente_en_casa

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox_status
    id: proxmox_status

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox2_status
    trigger_on_initial_state: true
    id: proxmox2_status

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox4_status
    id: proxmox4_status

number:
  - platform: template
    name: "Duración activa Pantalla"
    id: run_time
    min_value: 1
    max_value: 360000
    initial_value: 30
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true

  - platform: template
    name: "Tiempo en Deep Sleep Pantalla"
    id: sleep_time
    min_value: 10
    max_value: 3600
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true
    initial_value: 60

  - platform: template
    name: "Intervalo de refresco pantalla"
    id: refresh_control
    min_value: 1
    max_value: 120
    initial_value: 10
    step: 1
    unit_of_measurement: min
    restore_value: true
    optimistic: true
    # This value is used by the `refresh_loop` script (in minutes) to control how often the display
    # is updated when `Pantalla refresco habilitado` and `gente_en_casa` are true.


  - platform: template
    name: "Pantalla hora inicio"
    id: refresh_start_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 8
    optimistic: true
    restore_value: true

  - platform: template
    name: "Pantalla hora fin"
    id: refresh_end_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 22
    optimistic: true
    restore_value: true

  - platform: template
    name: "UI factor densidad"
    id: ui_density_factor
    min_value: -10
    max_value: 10
    initial_value: 0
    step: 1
    unit_of_measurement: "px"
    optimistic: true
    restore_value: true

output:
  - platform: gpio
    id: power_sensors
    pin: GPIO11

  - platform: gpio
    id: led_builtin
    pin: GPIO13
    inverted: false

deep_sleep:
  id: deep_sleep_1

script:
  - id: go_to_sleep_delayed
    then:
      - lambda: 'ESP_LOGI("sleep", "Scheduling deep sleep in 10s");'
      - delay: 10s
      - lambda: 'ESP_LOGI("sleep", "Preparing to enter deep sleep");'
      - output.turn_off: power_sensors
      - delay: 2s
      - globals.set:
          id: pantalla_activa
          value: 'false'
      - lambda: 'ESP_LOGI("sleep", "Entering deep sleep for %d s", (int)id(sleep_time).state);'
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'

  - id: ensure_painted_on_boot
    then:
      # Esperar tiempo válido
      - wait_until:
          timeout: 1min
          condition:
            lambda: 'return id(esptime).now().is_valid();'
      - delay: 500ms
      
      # Esperar conexión API de Home Assistant
      - wait_until:
          timeout: 30s
          condition:
            api.connected:
      - delay: 3s
      
      # Esperar que el sensor tenga datos o que exista caché válida
      - wait_until:
          timeout: 30s
          condition:
            lambda: |-
              return !id(calendario_eventos_raw).state.empty() || 
                     !id(calendario_json).empty();
      
      # Siempre forzar refresh en boot para garantizar pintado
      - globals.set:
          id: force_refresh
          value: 'true'
      
      # Procesar calendario y actualizar pantalla
      - script.execute: procesar_calendario
      - delay: 2500ms
      
      # Actualizar pantalla siempre en boot
      - component.update: main_display
      - delay: 1000ms
      - globals.set:
          id: cal_changed
          value: 'false'
      - globals.set:
          id: last_drawn_ok
          value: 'true'
      - globals.set:
          id: force_refresh
          value: 'false'
      
      # Si no hay gente en casa y autosleep activado, programar sleep
      - if:
          condition:
            and:
              - binary_sensor.is_off: gente_en_casa
              - switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "Boot complete, no people home -> scheduling sleep");'
            - script.execute: go_to_sleep_delayed
      # Si refresh está deshabilitado y autosleep activado, programar sleep
      - if:
          condition:
            and:
              - switch.is_off: refresh_enabled
              - switch.is_on: autosleep_enabled
              - binary_sensor.is_on: gente_en_casa
          then:
            - lambda: 'ESP_LOGI("sleep", "Boot complete and refresh disabled -> scheduling sleep");'
            - script.execute: go_to_sleep_delayed

  - id: refresh_loop
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Si no hay gente en casa y autosleep activado, ir a dormir
            - if:
                condition:
                  and:
                    - binary_sensor.is_off: gente_en_casa
                    - switch.is_on: autosleep_enabled
                then:
                  - lambda: 'ESP_LOGI("sleep", "refresh_loop: no people home -> scheduling sleep");'
                  - script.execute: go_to_sleep_delayed
                  - script.stop: refresh_loop
            # Si hay gente y refresh activado, actualizar
            - if:
                condition:
                  and:
                    - switch.is_on: refresh_enabled
                    - binary_sensor.is_on: gente_en_casa
                then:
                  - script.execute: procesar_calendario
                  - if:
                      condition:
                        lambda: 'return id(force_refresh) || id(cal_changed);'
                      then:
                        - component.update: main_display
                        - globals.set:
                            id: cal_changed
                            value: 'false'
                        - globals.set:
                            id: last_drawn_ok
                            value: 'true' 
            - delay: !lambda |-
                return (uint32_t)(id(refresh_control).state * 60 * 1000);

#Calendario
  - id: procesar_calendario
    then:
      - lambda: |-

          // Función auxiliar para trim (elimina espacios al inicio y final)
          auto trim = [](std::string &s) {
            s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) { return !std::isspace(ch); }));
            s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(), s.end());
          };
          // Función para normalizar texto (solo permite caracteres definidos en las fuentes)
          const std::string allowed_chars = "!\"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ";
          auto normalize = [allowed_chars](std::string &s) {
            for (char &c : s) {
              if (allowed_chars.find(c) == std::string::npos) {
                c = ' ';
              }
            }
          };
          // Función para truncar texto a longitud máxima
          auto truncate = [](std::string &s, size_t max_len) {
            if (s.size() > max_len) {
              s = s.substr(0, max_len);
            }
          };

          id(cal_day).clear();
          id(cal_title).clear();
          id(cal_time).clear();
          id(cal_location).clear();
          id(cal_when).clear();

          // Reset connection error tracking
          id(connection_error) = "";
          id(using_cache) = false;

          // Check WiFi connection
          if (!WiFi.isConnected()) {
            id(connection_error) = "Sin WiFi";
            ESP_LOGW("calendar", "WiFi not connected");
          }

          // Prefer HA sensor JSON, fallback to cached `calendario_json`
          const std::string &json_sensor = id(calendario_eventos_raw).state;
          std::string json_str;
          if (!json_sensor.empty()) {
            json_str = json_sensor;
            id(calendario_json) = json_sensor; // update persistent cache
            // Clear connection error if we got fresh data
            if (id(connection_error).empty() || id(connection_error) == "Sin WiFi") {
              id(connection_error) = "";
            }
          } else if (!id(calendario_json).empty()) {
            json_str = id(calendario_json);
            id(using_cache) = true;
            if (id(connection_error).empty()) {
              id(connection_error) = "Sin HA";
            }
            ESP_LOGI("calendar", "Usando JSON cacheado");
          } else {
            if (id(connection_error).empty()) {
              id(connection_error) = "Sin datos";
            }
            ESP_LOGW("calendar", "JSON vacío");
            id(cal_changed) = false;
            return;
          }

          ESP_LOGI("calendar", "procesar_calendario: sensor_len=%d cache_len=%d last_hash=%s cache_ts=%d",
                   (int)json_sensor.size(), (int)id(calendario_json).size(), id(last_calendar_hash).c_str(), id(calendario_cache_ts));



          // Get current time (used for TTL and timestamps)
          auto now = id(esptime).now();
          if (!now.is_valid()) {
            ESP_LOGW("calendar", "Hora no válida");
            id(cal_changed) = false;
            return;
          }

          tm now_tm = {};
          now_tm.tm_year = now.year - 1900;
          now_tm.tm_mon  = now.month - 1;
          now_tm.tm_mday = now.day_of_month;
          now_tm.tm_hour = now.hour;
          now_tm.tm_min  = now.minute;
          now_tm.tm_sec  = now.second;
          time_t now_ts = mktime(&now_tm);

          // If we used sensor JSON, store cache timestamp
          if (!json_sensor.empty()) {
            id(calendario_cache_ts) = (int)now_ts;
          } else if (id(calendario_cache_ts) != 0) {
            // Check TTL (12 hours)
            const int CACHE_TTL = 12 * 3600;
            if ((now_ts - (time_t)id(calendario_cache_ts)) > CACHE_TTL) {
              ESP_LOGW("calendar", "Cached JSON stale (%ld s), will request refresh", (long)(now_ts - (time_t)id(calendario_cache_ts)));
              id(force_refresh) = true;
            }
          }

          // Compute FNV-1a 64-bit hash of the JSON and store for cache
          uint64_t hash = 14695981039346656037ULL;
          for (char c : json_str) {
            hash ^= (uint8_t)c;
            hash *= 1099511628211ULL;
          }
          char hash_buf[17];
          snprintf(hash_buf, sizeof(hash_buf), "%016llx", (unsigned long long)hash);
          std::string hash_str(hash_buf);
          id(last_calendar_hash) = hash_str; 

          #pragma GCC diagnostic push
          #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
          StaticJsonDocument<16384> doc;
          #pragma GCC diagnostic pop
          DeserializationError err = deserializeJson(doc, json_str);
          if (err) {
            ESP_LOGE("calendar", "Error JSON: %s", err.c_str());
            return;
          }

          JsonArray arr = doc.as<JsonArray>();
          if (!now.is_valid()) {
            ESP_LOGW("calendar", "Hora no válida");
            return;
          }

          const char* dias[]   = {"dom.", "lun.", "mar.", "mié.", "jue.", "vie.", "sáb."};
          const char* meses[]  = {"ene", "feb", "mar", "abr", "may", "jun",
                                  "jul", "ago", "sep", "oct", "nov", "dic"};

          int shown = 0;

          for (JsonObject ev : arr) {
            if (shown >= 8) break;

            std::string start = ev["start"] | "";
            std::string end   = ev["end"]   | "";
            std::string title = ev["summary"] | "";
            std::string loc   = ev["location"] | "";

            if (start.size() < 10) continue;

            int y = stoi(start.substr(0,4));
            int m = stoi    (start.substr(5,2));
            int d = stoi(start.substr(8,2));
            int hh = (start.size() >= 16) ? stoi(start.substr(11,2)) : 0;
            int mm = (start.size() >= 16) ? stoi(start.substr(14,2)) : 0;

            tm timeinfo = {};
            timeinfo.tm_year = y - 1900;
            timeinfo.tm_mon  = m - 1;
            timeinfo.tm_mday = d;
            timeinfo.tm_hour = hh;
            timeinfo.tm_min  = mm;
            timeinfo.tm_sec  = 0;
            timeinfo.tm_isdst = -1;  // Let mktime determine DST

            // CRITICAL: Call mktime to compute tm_wday (day of week)!
            mktime(&timeinfo);

            // Normalize to midday to avoid DST edge issues
            tm now_tm = {};
            now_tm.tm_year = now.year - 1900;
            now_tm.tm_mon  = now.month - 1;
            now_tm.tm_mday = now.day_of_month;
            now_tm.tm_hour = 12;
            now_tm.tm_min  = 0;
            now_tm.tm_sec  = 0;

            time_t today_ts = mktime(&now_tm);

            tm ev_tm = timeinfo;
            ev_tm.tm_hour = 12;
            ev_tm.tm_min  = 0;
            ev_tm.tm_sec  = 0;

            time_t event_ts = mktime(&ev_tm);

            // ===== DIFERENCIA REAL EN DÍAS =====
            int days = (event_ts - today_ts) / 86400;

            char when_buf[20];
            if (days < 0) {
              // Ignorar eventos pasados
              continue;
            } else if (days == 0) {
              snprintf(when_buf, sizeof(when_buf), "(hoy)");
            } else if (days == 1) {
              snprintf(when_buf, sizeof(when_buf), "(mañana)");
            } else if (days < 30) {
              snprintf(when_buf, sizeof(when_buf), "(en %d días)", days);
            } else {
              snprintf(when_buf, sizeof(when_buf), "(+1 mes)");
            }

            char day_buf[20];
            snprintf(day_buf, sizeof(day_buf), "%s %d %s",
                    dias[timeinfo.tm_wday],
                    timeinfo.tm_mday,
                    meses[timeinfo.tm_mon]);

            char time_buf[20];
            if (start.size() >= 16 && end.size() >= 16) {
              snprintf(time_buf, sizeof(time_buf), "%s-%s",
                      start.substr(11,5).c_str(),
                      end.substr(11,5).c_str());
            } else {
              snprintf(time_buf, sizeof(time_buf), "Todo el día");
            }

            std::string day_str(day_buf);
            trim(day_str);
            normalize(day_str);
            id(cal_day).push_back(day_str);

            trim(title);
            normalize(title);
            id(cal_title).push_back(title);

            std::string time_str(time_buf);
            trim(time_str);
            normalize(time_str);
            id(cal_time).push_back(time_str);

            trim(loc);
            normalize(loc);
            truncate(loc, 50);
            id(cal_location).push_back(loc);

            std::string when_str(when_buf);
            trim(when_str);
            normalize(when_str);
            id(cal_when).push_back(when_str);

            ESP_LOGD("calendar", "Evento añadido: %s", title.c_str());
            ESP_LOGD("calendar", "Location añadido: %s", loc.c_str());
            shown++;
          }

          // Update last refresh timestamp
          char ts_buf[32];
          snprintf(ts_buf, sizeof(ts_buf), "%04d-%02d-%02d %02d:%02d:%02d",
                   now.year, now.month, now.day_of_month,
                   now.hour, now.minute, now.second);
          id(last_refresh) = std::string(ts_buf);

          ESP_LOGI("calendar", "Eventos procesados: %d", shown);

          // Compute hash of processed data to detect changes including "when" fields
          std::string processed_data;
          for (size_t i = 0; i < id(cal_title).size(); ++i) {
            processed_data += id(cal_title)[i] + "|" + id(cal_location)[i] + "|" + id(cal_time)[i] + "|" + id(cal_when)[i] + "|" + id(cal_day)[i] + "\n";
          }
          uint64_t proc_hash = 14695981039346656037ULL;
          for (char c : processed_data) {
            proc_hash ^= (uint8_t)c;
            proc_hash *= 1099511628211ULL;
          }
          char proc_hash_buf[17];
          snprintf(proc_hash_buf, sizeof(proc_hash_buf), "%016llx", (unsigned long long)proc_hash);
          std::string proc_hash_str(proc_hash_buf);

          if (proc_hash_str != id(last_processed_hash) || id(force_refresh)) {
            id(cal_changed) = true;
            id(last_processed_hash) = proc_hash_str;
            ESP_LOGI("calendar", "Processed data changed (hash %s), will paint", proc_hash_str.c_str());
          } else {
            id(cal_changed) = false;
            ESP_LOGI("calendar", "No changes in processed data (hash %s), skipping paint", proc_hash_str.c_str());
          }