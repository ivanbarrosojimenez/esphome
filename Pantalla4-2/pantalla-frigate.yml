esphome:
  name: pantalla-calendario-4-2-1
  friendly_name: pantalla-calendario-4-2-1

  includes: ["src/pantalla_helpers.h", "src/pantalla_config.h", "src/pantalla_fonts.h", "src/pantalla_draw.h", "src/pantalla_calendar_parser.h"]
  on_boot:
    priority: -10
    then:
      - output.turn_off: led_builtin
      - script.execute: ensure_painted_on_boot
      - script.execute: refresh_loop
# external_components removed to prefer local custom_components/waveshare_epaper
substitutions: !include ../configs/configs.yaml

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino
web_server:
  port: 80

logger:
 # level: ERROR

api:
  encryption:
    key: !secret api_key
  reboot_timeout: 0s

wifi:
  ssid: !secret wifi_ssid_madrid
  password: !secret wifi_password_madrid
  fast_connect: true
  manual_ip:
    static_ip: ${pantalla_madrid_4_2_1}
    gateway: ${net_gateway}
    subnet: ${net_mask}
    dns1: ${net_dns1}
    dns2: ${net_dns2}
  ap:
    ssid: "pantalla-c3-fallback"
    password: !secret ap_password

captive_portal:

ota:
  platform: esphome

globals:
  - id: pantalla_activa
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: force_refresh
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: last_refresh
    type: std::string
    restore_value: no
    initial_value: ''
#Calendario
  - id: calendario_json
    type: std::string
    restore_value: no
    initial_value: ''

  - id: last_calendar_hash
    type: std::string
    restore_value: no
    initial_value: ''

  - id: last_processed_hash
    type: std::string
    restore_value: no
    initial_value: ''

  - id: cal_changed
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: calendario_cache_ts
    type: int
    restore_value: yes
    initial_value: '0'

  - id: last_drawn_ok
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: using_cache
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: connection_error
    type: std::string
    restore_value: no
    initial_value: ''

  - id: eventos_texto
    type: std::vector<std::string>
    restore_value: no
  - id: cal_day
    type: std::vector<std::string>
    restore_value: no
  - id: cal_title
    type: std::vector<std::string>
    restore_value: no
  - id: cal_time
    type: std::vector<std::string>
    restore_value: no
  - id: cal_location
    type: std::vector<std::string>
    restore_value: no
  - id: cal_when
    type: std::vector<std::string>
    restore_value: no


color:
  # NOTE: e-paper display uses inverted colors compared to typical RGB: "ink" is white (#FFFFFF), "paper" is black (#000000)
  - id: color_negro
    hex: "FFFFFF"   # Ink color for e-paper (logical 'black')
  - id: color_blanco
    hex: "000000"   # Paper color for e-paper (logical 'white')
  - id: color_dark_gray
    red_int: 169
    green_int: 169
    blue_int: 169
  - id: color_light_gray
    red_int: 84
    green_int: 84
    blue_int: 84

font:
  # Fuentes para título (tamaños variables)
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_16
    size: 16
    glyphs: &glyphs >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_18
    size: 18
    glyphs: *glyphs
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_20
    size: 20
    glyphs: *glyphs
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_22
    size: 22
    glyphs: *glyphs
  - file: "../fonts/Palatino.ttf"
    id: fuente_titulo_24
    size: 24
    glyphs: *glyphs

  # Fuentes para fecha (tamaños variables)
  - file: "../fonts/Palatino.ttf"
    id: fuente_fecha_12
    size: 12
    glyphs: *glyphs
  - file: "../fonts/Palatino.ttf"
    id: fuente_fecha_16
    size: 16
    glyphs: *glyphs
  - file: "../fonts/Palatino.ttf"
    id: fuente_fecha_18
    size: 18
    glyphs: *glyphs
  - file: "../fonts/Palatino.ttf"
    id: fuente_fecha_20
    size: 20
    glyphs: *glyphs

  - file: "../fonts/AtkinsonHyperlegibleNext-Bold.otf"
    id: fuente_8
    size: 12
    glyphs: *glyphs


text_sensor:
#Sensor calendario
  - platform: homeassistant
    entity_id: sensor.calendario_barroso_eventos
    attribute: events_json
    id: calendario_eventos_raw

  - platform: template
    name: "Pantalla calendario last_refresh"
    id: pantalla_last_refresh
    lambda: |-
      return id(last_refresh);
# SPI (la e-paper no usa MISO)
spi:
  id: bus_epaper
  clk_pin: GPIO36      # SCL
  mosi_pin: GPIO35     # SDA (MOSI)

display:
  - platform: waveshare_epaper
    spi_id: bus_epaper
    display_mode: partial
    #display_mode: [ partial | full | fast | grayscale4 ]
    model: 4.20in-v2     # <- modelo del PR 6209
    cs_pin: GPIO10
    dc_pin: GPIO9
    reset_pin: GPIO8
    busy_pin: GPIO21
    rotation: 0
    # Automatic periodic updates disabled — controlled by `script.refresh_loop` using `refresh_control` (minutes)
    update_interval: never
    full_update_every: 300
    reset_duration: 200ms  # Aumentado para mejorar timing del reset (habitualmente 200–500ms en algunas unidades)
    auto_clear_enabled: false
    # Drawing logic extracted to src/pantalla_helpers.h — use draw_calendar(it)
    id: main_display
    lambda: |-
      draw_calendar(it);


#interval:
#  - interval: 900s
#    then:
#      - if:
#          condition:
#            and:
#              - switch.is_on: refresh_enabled
#              - binary_sensor.is_on: gente_en_casa
#          then:
#            - component.update: main_display


time:
  - platform: sntp
    id: esptime
    timezone: "Europe/Madrid"

button:
  - platform: restart
    name: "Reiniciar ESP Pantalla"

  - platform: template
    name: "Forzar Deep Sleep Pantalla"
    on_press:
      then:
        - output.turn_off: power_sensors
        - delay: 2s
        - deep_sleep.enter:
            id: deep_sleep_1
            sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'

switch:
  - platform: template
    name: "Actualizar pantalla manual"
    id: update_display
    turn_on_action:
      - globals.set:
          id: force_refresh
          value: 'true'
      - script.execute: procesar_calendario
      - delay: 2000ms
      
      # SIEMPRE actualizar pantalla cuando se pulsa el botón manual
      - component.update: main_display
      - delay: 500ms
      - globals.set:
          id: cal_changed
          value: 'false'
      - globals.set:
          id: last_drawn_ok
          value: 'true'
      - globals.set:
          id: force_refresh
          value: 'false'
      
      - if:
          condition:
            and:
              - switch.is_off: refresh_enabled
              - switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "Manual update complete and refresh disabled -> scheduling go_to_sleep_delayed");'
            - script.execute: go_to_sleep_delayed
      - switch.turn_off: update_display

  - platform: template
    name: "Pantalla refresco habilitado"
    id: refresh_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_off_action:
      - if:
          condition:
            switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "refresh disabled -> scheduling go_to_sleep_delayed");'
            - script.execute: go_to_sleep_delayed

  - platform: template
    name: "Pantalla auto-sleep habilitado"
    id: autosleep_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

select:
  - platform: template
    name: "UI tamaño fuente"
    id: ui_font_size
    options:
      - "12"
      - "14"
      - "16"
      - "18"
      - "20"
      - "22"
      - "24"
    initial_option: "16"
    optimistic: true
    restore_value: true
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("diag", "ui_font_size on_value: %s", x.c_str());

#Sensor HA
binary_sensor:
  - platform: homeassistant
    entity_id: input_boolean.gente_en_casa_madrid
    id: gente_en_casa

number:
  - platform: template
    name: "Duración activa Pantalla"
    id: run_time
    min_value: 1
    max_value: 360000
    initial_value: 30
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("diag", "run_time on_value: %f", x);

  - platform: template
    name: "Tiempo en Deep Sleep Pantalla"
    id: sleep_time
    min_value: 10
    max_value: 3600
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true
    initial_value: 60

  - platform: template
    name: "Intervalo de refresco pantalla"
    id: refresh_control
    min_value: 1
    max_value: 120
    initial_value: 30
    step: 1
    unit_of_measurement: min
    restore_value: true
    optimistic: true
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("diag", "refresh_control on_value: %f", x);
    # This value is used by the `refresh_loop` script (in minutes) to control how often the display
    # is updated when `Pantalla refresco habilitado` and `gente_en_casa` are true.


  - platform: template
    name: "Pantalla hora inicio"
    id: refresh_start_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 7
    optimistic: true
    restore_value: true
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("diag", "refresh_start_hour on_value: %f", x);

  - platform: template
    name: "Pantalla hora fin"
    id: refresh_end_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 23
    optimistic: true
    restore_value: true
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("diag", "refresh_end_hour on_value: %f", x);

  - platform: template
    name: "UI factor densidad"
    id: ui_density_factor
    min_value: -10
    max_value: 10
    initial_value: 2
    step: 1
    unit_of_measurement: "px"
    optimistic: true
    restore_value: true
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("diag", "ui_density_factor on_value: %f", x);

output:
  - platform: gpio
    id: power_sensors
    pin: GPIO11

  - platform: gpio
    id: led_builtin
    pin: GPIO13
    inverted: false

deep_sleep:
  id: deep_sleep_1

script:
  - id: go_to_sleep_delayed
    then:
      - lambda: 'ESP_LOGI("sleep", "Scheduling deep sleep in 10s");'
      - delay: 10s
      - lambda: 'ESP_LOGI("sleep", "Preparing to enter deep sleep");'
      - output.turn_off: power_sensors
      - delay: 2s
      - globals.set:
          id: pantalla_activa
          value: 'false'
      - lambda: 'ESP_LOGI("sleep", "Entering deep sleep for %d s", (int)id(sleep_time).state);'
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'

  - id: ensure_painted_on_boot
    then:
      # Esperar tiempo válido
      - wait_until:
          timeout: 1min
          condition:
            lambda: 'return id(esptime).now().is_valid();'
      - delay: 500ms
      
      # Esperar conexión API de Home Assistant
      - wait_until:
          timeout: 30s
          condition:
            api.connected:
      - delay: 3s
      
      # Esperar que el sensor tenga datos o que exista caché válida
      - wait_until:
          timeout: 30s
          condition:
            lambda: |-
              return !id(calendario_eventos_raw).state.empty() || 
                     !id(calendario_json).empty();
      
      # Siempre forzar refresh en boot para garantizar pintado
      - globals.set:
          id: force_refresh
          value: 'true'
      
      # Procesar calendario y actualizar pantalla
      - script.execute: procesar_calendario
      - delay: 2500ms
      
      # Actualizar pantalla siempre en boot
      - component.update: main_display
      - delay: 1000ms
      - globals.set:
          id: cal_changed
          value: 'false'
      - globals.set:
          id: last_drawn_ok
          value: 'true'
      - globals.set:
          id: force_refresh
          value: 'false'
      
      # Si no hay gente en casa y autosleep activado, programar sleep
      - if:
          condition:
            and:
              - binary_sensor.is_off: gente_en_casa
              - switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "Boot complete, no people home -> scheduling sleep");'
            - script.execute: go_to_sleep_delayed
      # Si refresh está deshabilitado y autosleep activado, programar sleep
      - if:
          condition:
            and:
              - switch.is_off: refresh_enabled
              - switch.is_on: autosleep_enabled
              - binary_sensor.is_on: gente_en_casa
          then:
            - lambda: 'ESP_LOGI("sleep", "Boot complete and refresh disabled -> scheduling sleep");'
            - script.execute: go_to_sleep_delayed

  - id: refresh_loop
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            # Si no hay gente en casa y autosleep activado, ir a dormir
            - if:
                condition:
                  and:
                    - binary_sensor.is_off: gente_en_casa
                    - switch.is_on: autosleep_enabled
                then:
                  - lambda: 'ESP_LOGI("sleep", "refresh_loop: no people home -> scheduling sleep");'
                  - script.execute: go_to_sleep_delayed
                  - script.stop: refresh_loop
            # Si hay gente y refresh activado, actualizar
            - if:
                condition:
                  and:
                    - switch.is_on: refresh_enabled
                    - binary_sensor.is_on: gente_en_casa
                then:
                  - script.execute: procesar_calendario
                  - if:
                      condition:
                        lambda: 'return id(force_refresh) || id(cal_changed);'
                      then:
                        - component.update: main_display
                        - globals.set:
                            id: cal_changed
                            value: 'false'
                        - globals.set:
                            id: last_drawn_ok
                            value: 'true' 
            - delay: !lambda |-
                return (uint32_t)(id(refresh_control).state * 60 * 1000);

#Calendario
  - id: procesar_calendario
    then:
      - lambda: |- 
          procesar_calendario_impl();