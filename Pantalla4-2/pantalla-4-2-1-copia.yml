esphome:
  name: pantalla-calendario-4-2-1
  friendly_name: pantalla-calendario-4-2-1
  includes: ["src/pantalla_helpers.h"]
  on_boot:
    priority: -10
    then:
      - script.execute: ensure_painted_on_boot
      - script.execute: refresh_loop
external_components:
  - source: github://pr#6209
    components: [ waveshare_epaper ]
    refresh: 5min


esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino
web_server:
  port: 80

logger:
 # level: ERROR

api:
  encryption:
    key: !secret api_key
  reboot_timeout: 0s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  ap:
    ssid: "pantalla-c3-fallback"
    password: !secret ap_password

captive_portal:

ota:
  platform: esphome

globals:
  - id: pantalla_activa
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: force_refresh
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: last_refresh
    type: std::string
    restore_value: no
    initial_value: ''
#Calendario
  - id: calendario_json
    type: std::string
    restore_value: no

  - id: eventos_texto
    type: std::vector<std::string>
    restore_value: no
  - id: cal_day
    type: std::vector<std::string>
  - id: cal_title
    type: std::vector<std::string>
  - id: cal_time
    type: std::vector<std::string>
  - id: cal_location
    type: std::vector<std::string>
  - id: cal_when
    type: std::vector<std::string>


color:
  - id: color_negro
    hex: "FFFFFF"   # Invertido para e-paper
  - id: color_blanco
    hex: "000000"   # Invertido para e-paper
  - id: color_dark_gray
    red_int: 169
    green_int: 169
    blue_int: 169
  - id: color_light_gray
    red_int: 84
    green_int: 84
    blue_int: 84


font:
  - file: "../fonts/Palatino.ttf"
    id: fuente_28
    size: 20
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ
  - file: "../fonts/Palatino.ttf"
    id: fuente_14
    size: 16
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ

  - file: "../fonts/Roboto.ttf"
    id: fuente_8_2
    size: 12
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ

  - file: "../fonts/AtkinsonHyperlegibleNext-Bold.otf"
    id: fuente_8
    size: 12
    glyphs: >-
      !"#$%&'()*+,-./:;=?@°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz áéíóúÁÉÍÓÚñÑüÜ¿¡ÀÈÌÒÙàèìòùâêîôûÂÊÎÔÛäëïöÄËÏÖ


sensor:
  #Temperaturas
  - platform: homeassistant
    entity_id: sensor.calidad_aire_madrid_temperature
    id: temperatura_interior
  - platform: homeassistant
    entity_id: sensor.calidad_aire_madrid_humidity
    id: humedad_interior


  - platform: homeassistant
    entity_id: sensor.temperatura_calle_solar_madrid_temperature
    id: temperatura_exterior
  - platform: homeassistant
    entity_id: sensor.temperatura_calle_solar_madrid_humidity
    id: humedad_exterior
  

text_sensor:
#Sensor calendario
  - platform: homeassistant
    entity_id: sensor.calendario_barroso_eventos
    attribute: events_json
    id: calendario_eventos_raw
# SPI (la e-paper no usa MISO)
spi:
  id: bus_epaper
  clk_pin: GPIO36      # SCL
  mosi_pin: GPIO35     # SDA (MOSI)

display:
  - platform: waveshare_epaper
    spi_id: bus_epaper
    display_mode: grayscale4
    #display_mode: [ partial | full | fast | grayscale4 ]
    model: 4.20in-v2     # <- modelo del PR 6209
    cs_pin: GPIO10
    dc_pin: GPIO9
    reset_pin: GPIO8
    busy_pin: GPIO21
    rotation: 0
    # Automatic periodic updates disabled — controlled by `script.refresh_loop` using `refresh_control` (minutes)
    update_interval: never
    full_update_every: 300
    reset_duration: 200ms  # Aumentado para mejorar timing del reset (habitualmente 200–500ms en algunas unidades)
    #auto_clear_enabled: false
    # Drawing logic extracted to src/pantalla_helpers.h — use draw_calendar(it)
    id: main_display
    lambda: |-
      draw_calendar(it);


#interval:
#  - interval: 900s
#    then:
#      - if:
#          condition:
#            and:
#              - switch.is_on: refresh_enabled
#              - binary_sensor.is_on: gente_en_casa
#          then:
#            - component.update: main_display


time:
  - platform: sntp
    id: esptime
    timezone: "Europe/Madrid"

button:
  - platform: restart
    name: "Reiniciar ESP Pantalla"

  - platform: template
    name: "Forzar Deep Sleep Pantalla"
    on_press:
      then:
        - output.turn_off: power_sensors
        - delay: 2s
        - deep_sleep.enter:
            id: deep_sleep_1
            sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'

switch:
  - platform: template
    name: "Actualizar pantalla manual"
    id: update_display
    turn_on_action:
      - globals.set:
          id: force_refresh
          value: 'true'
      - script.execute: procesar_calendario
      - delay: 1000ms
      - component.update: main_display
      - delay: 200ms
      - globals.set:
          id: force_refresh
          value: 'false'
      - if:
          condition:
            and:
              - switch.is_off: refresh_enabled
              - switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "Manual update complete and refresh disabled -> scheduling go_to_sleep_delayed");'
            - script.execute: go_to_sleep_delayed
      - switch.turn_off: update_display

  - platform: template
    name: "Pantalla refresco habilitado"
    id: refresh_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_off_action:
      - if:
          condition:
            switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "refresh disabled -> scheduling go_to_sleep_delayed");'
            - script.execute: go_to_sleep_delayed

  - platform: template
    name: "Pantalla auto-sleep habilitado"
    id: autosleep_enabled
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

#Sensor HA
binary_sensor:
  - platform: homeassistant
    entity_id: input_boolean.gente_en_casa_madrid
    id: gente_en_casa

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox_status
    id: proxmox_status

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox2_status
    trigger_on_initial_state: true
    id: proxmox2_status

  - platform: homeassistant
    entity_id: binary_sensor.node_proxmox4_status
    id: proxmox4_status

number:
  - platform: template
    name: "Duración activa Pantalla"
    id: run_time
    min_value: 1
    max_value: 360000
    initial_value: 12000
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true

  - platform: template
    name: "Tiempo en Deep Sleep Pantalla"
    id: sleep_time
    min_value: 10
    max_value: 3600
    step: 1
    unit_of_measurement: s
    restore_value: true
    optimistic: true
    initial_value: 60

  - platform: template
    name: "Intervalo de refresco pantalla"
    id: refresh_control
    min_value: 1
    max_value: 120
    initial_value: 10
    step: 1
    unit_of_measurement: min
    restore_value: true
    optimistic: true
    # This value is used by the `refresh_loop` script (in minutes) to control how often the display
    # is updated when `Pantalla refresco habilitado` and `gente_en_casa` are true.


  - platform: template
    name: "Pantalla hora inicio"
    id: refresh_start_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 8
    optimistic: true
    restore_value: true

  - platform: template
    name: "Pantalla hora fin"
    id: refresh_end_hour
    min_value: 0
    max_value: 23
    step: 1
    initial_value: 22
    optimistic: true
    restore_value: true

output:
  - platform: gpio
    id: power_sensors
    pin: GPIO11

deep_sleep:
  id: deep_sleep_1

script:
  - id: go_to_sleep_delayed
    then:
      - lambda: 'int sec = (int)id(run_time).state; if (sec <= 3) sec = 3; ESP_LOGI("sleep", "Scheduling deep sleep in %d s", sec - 2);'
      - delay: !lambda 'uint32_t sec = (uint32_t)id(run_time).state; if (sec <= 3) sec = 3; return (uint32_t)(sec - 2) * 1000;'
      - lambda: 'ESP_LOGI("sleep", "Preparing to enter deep sleep");'
      - output.turn_off: power_sensors
      - delay: 2s
      - globals.set:
          id: pantalla_activa
          value: 'false'
      - lambda: 'ESP_LOGI("sleep", "Entering deep sleep for %d s", (int)id(sleep_time).state);'
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: !lambda 'return (uint32_t) id(sleep_time).state * 1000;'

  - id: ensure_painted_on_boot
    then:
      - wait_until:
          timeout: 1min
          condition:
            lambda: 'return id(esptime).now().is_valid();'
      - delay: 500ms
      - globals.set:
          id: force_refresh
          value: 'true'
      - script.execute: procesar_calendario
      - delay: 1500ms
      - component.update: main_display
      - delay: 800ms
      # Reintento simple: si hacemos un boot forzado, volver a actualizar una vez más (ayuda a recuperarse de timeouts)
      - if:
          condition:
            lambda: 'return id(force_refresh);'
          then:
            - delay: 500ms
            - component.update: main_display
            - delay: 800ms
      - globals.set:
          id: force_refresh
          value: 'false'
      - if:
          condition:
            and:
              - switch.is_off: refresh_enabled
              - switch.is_on: autosleep_enabled
          then:
            - lambda: 'ESP_LOGI("sleep", "Boot update complete and refresh disabled -> scheduling go_to_sleep_delayed");'
            - script.execute: go_to_sleep_delayed

  - id: refresh_loop
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - if:
                condition:
                  and:
                    - switch.is_on: refresh_enabled
                    - binary_sensor.is_on: gente_en_casa
                then:
                  - script.execute: procesar_calendario
                  - component.update: main_display
            - delay: !lambda |-
                return (uint32_t)(id(refresh_control).state * 60 * 1000);

#Calendario
  - id: procesar_calendario
    then:
      - lambda: |-

          id(cal_day).clear();
          id(cal_title).clear();
          id(cal_time).clear();
          id(cal_location).clear();
          id(cal_when).clear();

          const std::string &json_str = id(calendario_eventos_raw).state;
          if (json_str.empty()) {
            ESP_LOGW("calendar", "JSON vacío");
            return;
          }

          #pragma GCC diagnostic push
          #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
          StaticJsonDocument<16384> doc;
          #pragma GCC diagnostic pop
          DeserializationError err = deserializeJson(doc, json_str);
          if (err) {
            ESP_LOGE("calendar", "Error JSON: %s", err.c_str());
            return;
          }

          JsonArray arr = doc.as<JsonArray>();
          auto now = id(esptime).now();
          if (!now.is_valid()) {
            ESP_LOGW("calendar", "Hora no válida");
            return;
          }

          const char* dias[]   = {"dom.", "lun.", "mar.", "mié.", "jue.", "vie.", "sáb."};
          const char* meses[]  = {"ene", "feb", "mar", "abr", "may", "jun",
                                  "jul", "ago", "sep", "oct", "nov", "dic"};

          int shown = 0;

          for (JsonObject ev : arr) {
            if (shown >= 8) break;

            std::string start = ev["start"] | "";
            std::string end   = ev["end"]   | "";
            std::string title = ev["summary"] | "";
            std::string loc   = ev["location"] | "";

            if (start.size() < 10) continue;

            int y = stoi(start.substr(0,4));
            int m = stoi    (start.substr(5,2));
            int d = stoi(start.substr(8,2));
            int hh = (start.size() >= 16) ? stoi(start.substr(11,2)) : 0;
            int mm = (start.size() >= 16) ? stoi(start.substr(14,2)) : 0;

            tm timeinfo = {};
            timeinfo.tm_year = y - 1900;
            timeinfo.tm_mon  = m - 1;
            timeinfo.tm_mday = d;
            timeinfo.tm_hour = hh;
            timeinfo.tm_min  = mm;
            timeinfo.tm_sec  = 0;

            time_t ev_ts = mktime(&timeinfo);

            // ===== NORMALIZAR "HOY" A MEDIANOCHE =====
            tm now_tm = {};
            now_tm.tm_year = now.year - 1900;
            now_tm.tm_mon  = now.month - 1;
            now_tm.tm_mday = now.day_of_month;
            now_tm.tm_hour = 0;
            now_tm.tm_min  = 0;
            now_tm.tm_sec  = 0;

            time_t today_ts = mktime(&now_tm);

            // ===== NORMALIZAR EVENTO A MEDIANOCHE (USANDO timeinfo REAL) =====
            tm ev_tm = timeinfo;
            ev_tm.tm_hour = 0;
            ev_tm.tm_min  = 0;
            ev_tm.tm_sec  = 0;

            time_t event_ts = mktime(&ev_tm);

            // ===== DIFERENCIA REAL EN DÍAS =====
            int days = (event_ts - today_ts) / 86400;

            char when_buf[20];
            if (days < 0) {
              snprintf(when_buf, sizeof(when_buf), "(hoy)");
            } else if (days == 0) {
              snprintf(when_buf, sizeof(when_buf), "(hoy)");
            } else if (days == 1) {
              snprintf(when_buf, sizeof(when_buf), "(mañana)");
            } else if (days < 30) {
              snprintf(when_buf, sizeof(when_buf), "(en %d días)", days);
            } else {
              snprintf(when_buf, sizeof(when_buf), "(+1 mes)");
            }

            char day_buf[20];
            snprintf(day_buf, sizeof(day_buf), "%s %d %s",
                    dias[timeinfo.tm_wday],
                    timeinfo.tm_mday,
                    meses[timeinfo.tm_mon]);

            char time_buf[20];
            if (start.size() >= 16 && end.size() >= 16) {
              snprintf(time_buf, sizeof(time_buf), "%s-%s",
                      start.substr(11,5).c_str(),
                      end.substr(11,5).c_str());
            } else {
              snprintf(time_buf, sizeof(time_buf), "Todo el día");
            }

            id(cal_day).push_back(day_buf);
            id(cal_title).push_back(title);

            id(cal_time).push_back(time_buf);
            id(cal_location).push_back(loc);
            id(cal_when).push_back(when_buf);

            ESP_LOGD("calendar", "Evento añadido: %s", title.c_str());
            shown++;
          }

          ESP_LOGI("calendar", "Eventos procesados: %d", shown);